# HTML&CSS

## 页面布局

> 问题：假设容器的高度默认100px，请写出**三栏布局**，其中左栏、右栏的宽度各为300px，中间的宽度自适应。
>

### 方法

**方法1、浮动：**

左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。

**方法2、绝对定位：**

左侧设置为绝对定位，  `left：0px`。右侧设置为绝对定位， `right：0px`。中间设置为绝对定位，`left 和right 都为300px`，即可。中间的宽度会自适应。

使用`article`标签作为容器，包裹左、中、右三个部分。

**方法3、flexbox布局**

`flex：1`即为`flex-grow：1`，经常用作自适应布局，将父容器的`display：flex`，侧边栏大小固定后，将内容区`flex：1`，内容区则会自动放大占满剩余空间。

**方法4、表格布局 table**

设置整个容器的宽度为`100%`，设置三个部分均为表格，然后左边的单元格为 `300px`，右边的单元格为 `300px`，即可。中间的单元格会自适应。

**方法5、网格布局 grid**

设置容器为网格布局`display: grid`，宽度为`100%` 设置网格为三列，并设置每列的宽度`grid-template-columns: 300px auto 300px`。

### 效果

[![5mDMKs.gif](https://z3.ax1x.com/2021/10/12/5mDMKs.gif)](https://imgtu.com/i/5mDMKs)

### 代码

````html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>页面布局</title>
    <style>
        html *{
            padding: 0;
            margin: 0;
        }
        .layout article div{
            height: 100px;
        }
        .layout{
            margin-top: 20px;
        }
        /* 1.浮动 */
        /* .layout.float表示交集选择器，空格表示后代选择器 */
        .layout.float .left{
            float: left;
            width: 300px;
            background: red;
        }
        .layout.float .right{
            float: right;
            width: 300px;
            background: blue;
        }
        .layout.float .center{
            background: green;
        }
        /* 2.绝对定位 */
        .layout.absolute{
            margin-top: 100px;
        }
        .layout.absolute .left{
            position: absolute;
            left: 0;
            width: 300px;
            background: red;
        }
        /* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */
        .layout.absolute .center{
            position: absolute;
            left: 300px;
            right: 300px;
            background: green;
        }
        .layout.absolute .right{
            position: absolute;
            right: 0;
            width: 300px;
            background: blue;
        }
        /* 3.flex */
        /* 绝对布局导致脱离文档流，因此上边距300px是从方法一中还在文档流的元素开始算 */
        .layout.flex{
            margin-top: 230px;
        }
        .layout.flex .left-center-right{
            display: flex;
        }
        .layout.flex .left {
            width: 300px;
            background: red;
        }

        .layout.flex .center {
            flex: 1;
            background: green;
        }

        .layout.flex .right {
            width: 300px;
            background: blue;
        }
        /* 4.表格 */
        /* 重要：设置容器为表格布局，宽度为100% */
        .layout.table .left-center-right{
            width: 100%;
            display: table;
        }
        /* 重要：设置三个模块为表格里的单元*/
        .layout.table .left-center-right div{
            display: table-cell;
        }
        .layout.table .left{
            width: 300px;
            background: red;
        }
        .layout.table .center {
            background: green;
        }

        .layout.table .right {
            width: 300px;
            background: blue;
        }
        /* 5.网格 */
        /* 重要：设置容器为网格布局，宽度为100% */
        /* 设置网格为三列，并设置每列的宽度。即可。 */
        .layout.grid .left-center-right{
            display: grid;
            width: 100%;
            /* grid-template-rows: 100px; */
            grid-template-columns: 300px auto 300px;
        }
        .layout.grid .left {
            background: red;
        }
        .layout.grid .center {
            background: green;
        }
        .layout.grid .right {
            background: blue;
        }
    </style>
</head>
<body>
    <!-- 方法一：浮动 -->
    <!-- 
        元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，
         所以元素下边的还在文档流中的元素会自动向上移动 
    -->
    <!-- 输入 section.layout.float，即可生成 -->
    <section class="layout float">
        <!-- 用article标签包裹左、中、右三个部分 -->
        <article class="left-center-right">
            <div class="left">
                left
            </div>
            <div class="right">
                right
            </div>
            <div class="center">
                <h1>浮动</h1>
                center
            </div>
        </article>
    <!-- 方法二：绝对定位 -->
    </section>
    <section class="layout absolute">
        <article class="left-center-right">
            <div class="left">
                left
            </div>
            <div class="center">
                <h1>绝对定位</h1>
                center
            </div>
            <div class="right">
                right
            </div>
        </article>
    </section>
    <!-- 方法三：flex -->
    <section class="layout flex">
        <article class="left-center-right">
            <div class="left">
                我是 left
            </div>
            <div class="center">
                <h1>flex布局</h1>
                我是 center
            </div>
            <div class="right">
                我是 right
            </div>
        </article>
    </section>
    <!-- 方法四、表格 -->
    <section class="layout table">
        <article class="left-center-right">
            <div class="left">
                left
            </div>
            <div class="center">
                <h1>表格布局</h1>
                center
            </div>
            <div class="right">
                right
            </div>
        </article>
    </section>
    <!-- 方法五、网格 -->
    <section class="layout grid">
        <article class="left-center-right">
            <div class="left">
                left
            </div>
            <div class="center">
                <h1>网格布局</h1>
                center
            </div>
            <div class="right">
                right
            </div>

        </article>
    </section>
</body>
</html>
````

### 延伸

#### 五种方法的对比

- 五种方法的优缺点

- 考虑中间模块的高度问题

- 兼容性问题：实际开发中，哪个最实用？


方法1：浮动：

- 优点：兼容性较好。

- 缺点：浮动是**脱离文档流**的，如果处理不好，会带来很多问题。有些时候需要**清除浮动**，需要很好的处理浮动周边元素的关系。


方法:2：绝对定位


- 优点：快捷。

- 缺点：**布局脱离文档流，意味着下面的子元素也要脱离文档流**，导致这个方案的有效性是比较差的。


方法3：flex 布局

- 优点：比较完美的解决了浮动和绝对定位的问题。在移动端比较常用。
- 缺点：兼容性比较差，不兼容**IE8**及以下的版本。因为这个是**CSS3**中新增的display的属性值。


方法4：表格布局

- 优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局。

- 缺点：因为三个部分都当成了**单元格**来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。

方法5：网格布局

- CSS3中引入的布局，很好用。代码量简化了很多。

PS：面试提到网格布局，说明我们对新技术是有追求的。

#### 如果题目中去掉高度已知

问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？

[![5my7i6.gif](https://z3.ax1x.com/2021/10/12/5my7i6.gif)](https://imgtu.com/i/5my7i6)

#### 页面布局的变通

三栏布局

- 左右宽度固定，中间自适应
- 上下高度固定，中间自适应

两栏布局

- 左宽度固定，右自适应
- 右宽度固定，左自适应
- 上宽度固定，下自适应
- 下宽度固定，上自适应

### 总结

涉及到的知识点：

（1）语义化掌握到位：每个区域用`section`、`article`代表容器、`div`代表块儿。如果通篇都用 div，那就是语义化没掌握好。

（2）页面布局理解深刻。

（3）CSS基础知识扎实。

（4）思维灵活且积极上进。题目中可以通过`网格布局`来体现。

（5）代码书写规范。注意命名。

## 对CSS盒模型的认识

> 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面：
>
> （1）基本概念：content、padding、margin。
>
> （2）标准盒模型、IE盒模型的区别。
>
> （3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。
>
> （4）JS如何设置、获取盒模型对应的宽和高？
>
> （5）实例题：根据盒模型解释**边距重叠**。
>
> （6）BFC（边距重叠解决方案）或IFC。
>
> **总结**：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论。

### 标准盒模型和IE盒子模型

[![5mcYjg.jpg](https://z3.ax1x.com/2021/10/12/5mcYjg.jpg)](https://imgtu.com/i/5mcYjg)
[![5mcJgS.jpg](https://z3.ax1x.com/2021/10/12/5mcJgS.jpg)](https://imgtu.com/i/5mcJgS)

在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：


- width和height：**内容**的宽度、高度（不是盒子的宽度、高度）。
- padding：内边距。
- border：边框。
- margin：外边距。

CSS盒模型和IE盒模型的区别：

 - 在 **标准盒子模型**中，**width 和 height 指的是内容区域**的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。
 - **IE盒子模型**中，**width 和 height 指的是内容区域+border+padding**的宽度和高度。

### CSS如何设置这两种模型


```css
/* 设置当前盒子为 标准盒模型（默认） */
box-sizing: content-box;
/* 设置当前盒子为 IE盒模型 */
box-sizing: border-box;
```


备注：盒子默认为标准盒模型。

### JS如何设置、获取盒模型对应的宽和高

**方式一：通过DOM节点的 style 样式获取**


```javascript
element.style.width/height;
```

缺点：通过这种方式，只能获取**行内样式**，不能获取`内嵌`的样式和`外链`的样式。

这种方式有局限性，但应该了解。

**方式二（通用型）**


```javascript
window.getComputedStyle(element).width/height;
```


方式二能兼容 Chrome、火狐。是通用型方式。

**方式三（IE独有的）**


```javascript
element.currentStyle.width/height;
```

和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。

**方式四**


```javascript
element.getBoundingClientRect().width/height;
```

此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。

此 api 可以拿到四个属性：left、top、width、height。

**总结：**

上面的四种方式，要求能说出来区别，以及哪个的通用型更强。

### margin塌陷/margin重叠

**标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin**(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。

PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。

我们来看几个例子。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .father{
            background: green;
            /* overflow: hidden; */
        }
        .son{
            height: 50px;
            margin-top: 50px;
            margin-bottom: 20px;
            background: blue;
        }
        .brother{
            height: 50px;
            margin-top: 30px;
            background: red;
        }


    </style>
</head>

<body>
    <div class="father">
        <div class="son"></div>
        <div class="brother"></div>   
    </div>
</body>

</html>
```

上面的代码中，儿子和兄弟的height是 100px，儿子magin-top 是50px，margin-bottom是20px，兄弟magin-top 是30px。竖直方向的margin不叠加，只取较大的值作为margin，所以中间20px塌陷在30px中。另外，此时父亲的height 是130px，而不是180px。因为儿子和父亲在竖直方向上，共一个margin。

[![5mxrPx.png](https://z3.ax1x.com/2021/10/12/5mxrPx.png)](https://imgtu.com/i/5mxrPx)
[![5mx0aR.png](https://z3.ax1x.com/2021/10/12/5mx0aR.png)](https://imgtu.com/i/5mx0aR)

上方代码中，如果我们给父亲设置一个属性：`overflow: hidden`，就可以避免这个问题，此时父亲的高度是180px，这个用到的就是**BFC**。或者为父元素加一个`border: 2px solid red`

**margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。**

所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。

### BFC（边距重叠解决方案）

#### BFC的概念

BFC（Block Formatting Context）：块级格式化上下文。是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

#### BFC 的原理/BFC的布局规则【非常重要】

BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：

- BFC **内部的**子元素，在垂直方向，**边距会发生重叠**。

- BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看`举例1`）

- **BFC区域不与旁边的`float box`区域重叠**。（可以用来清除浮动带来的影响）。（稍后看`举例2`）

- 计算BFC的高度时，浮动的子元素也参与计算。（稍后看`举例3`）

#### 如何生成BFC

有以下几种方法：

- 方法1：`overflow: 不为visible，可以让属性是 hidden、auto`。【最常用】

- 方法2：浮动中：float的属性值不为none。意思是，`只要设置了浮动，当前元素就创建了BFC`。

- 方法3：定位中：只要posiiton的值不是static或者是relative即可，可以是`absolute`或`fixed`，也就生成了一个BFC。

- 方法4：`display`为`inline-block`, `table-cell`, `table-caption`, `flex`, `inline-flex`

#### BFC 的应用

> **举例1：**解决 margin 重叠

当父元素和子元素发生 margin 重叠时，解决办法：**给子元素或父元素创建BFC**。

比如说，针对下面这样一个 div 结构：


```html
<div class="father">
    <p class="son"></p>
</div>
```

上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：


```html
<div class="father">
    <p class="son" style="overflow: hidden">
    </p>
</div>
```

因为**第二条：BFC区域是一个独立的区域，不会影响外面的元素**。

> **举例2**：BFC区域不与float区域重叠：

针对下面这样一个div结构；

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>

        .father-layout {
            background: pink;
        }

        .father-layout .left {
            float: left;
            width: 100px;
            height: 100px;
            background: green;
        }

        .father-layout .right {
            height: 150px;  /*右侧标准流里的元素，比左侧浮动的元素要高*/
            background: red;
        }

    </style>
</head>
<body>

<section class="father-layout">
    <div class="left">
        左侧，1234
    </div>
    <div class="right">
        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，
    </div>
</section>

</body>
</html>
```

效果如下：

[![5nFuEF.png](https://z3.ax1x.com/2021/10/12/5nFuEF.png)](https://imgtu.com/i/5nFuEF)

上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。

**如果要解决这个问题，可以将右侧的元素创建BFC**，因为**第三条：BFC区域不与`float box`区域重叠**。解决办法如下：（将right区域添加overflow属性）

```html
<div class="right" style="overflow: hidden">
    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，
</div>
```

[![5nFKN4.png](https://z3.ax1x.com/2021/10/12/5nFKN4.png)](https://imgtu.com/i/5nFKN4)

上图表明，解决之后，`father-layout`的背景色显现出来了，说明问题解决了。

> **举例3：**清除浮动

现在有下面这样的结构：


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFC</title>
    <style>

        .father {
            background: pink;
            /* overflow: hidden; */
        }

        .son {
            float: left;
            background: green;
        }

    </style>
</head>
<body>
    <section class="father">
        <div class="son">
            hello son
        </div>
    </section>
</body>
</html>
```

效果如下：

[![5niapn.png](https://z3.ax1x.com/2021/10/12/5niapn.png)](https://imgtu.com/i/5niapn)

上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓**有高度的盒子，才能关住浮动**。

如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。

方法二是 BFC：给父亲增加 `overflow=hidden`属性即可， 增加之后，效果如下：

[![5niNfs.png](https://z3.ax1x.com/2021/10/12/5niNfs.png)](https://imgtu.com/i/5niNfs)

为什么父元素成为BFC之后，就有了高度呢？这就回到了**第四条：计算BFC的高度时，浮动元素也参与计算**。意思是，**在计算BFC的高度时，子元素的float box也会参与计算**。

## CSS中的权重、link和@import区别

### link和@import区别

**1.从属关系区别**
`@import`是 CSS 提供的语法规则，只有导入样式表的作用；`link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**
加载页面时，`link`标签引入的 CSS 被同时加载；`@import`引入的 CSS 将在页面加载完毕后被加载。

**3.兼容性区别**
`@import`是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；`link`标签作为 HTML 元素，不存在兼容性问题。

**4.DOM可控性区别**
可以通过 JS 操作 DOM ，插入`link`标签来改变样式；由于 DOM 方法是基于文档的，无法使用`@import`的方式插入样式。

**5.权重区别(该项有争议)**
`link`引入的样式权重大于`@import`引入的样式。

### CSS 中的权重

说到“权重”，有必要再解释一下：CSS 中的权重，指的是**选择器的优先级**。

CSS 选择器的权重高，即选择器的优先级高。CSS 的优先级特性表现为，对同一 HTML 元素设置样式时，不同选择器的优先级不同，优先级低的样式将被高优先级的样式层叠掉。

CSS 权重优先级顺序简单表示为：

`!important > 内联样式 > ID > 类、伪类、属性 > 标签名、伪元素  > 通配符`

| 选择器                                                   | 权重        |
| -------------------------------------------------------- | ----------- |
| 通配符 `*`                                               | 0           |
| 标签 伪元素 选择器`p{}  h1{}  div{}`/`::after, ::before` | 1           |
| 类/伪类/属性 `.class属性值` /`:nth-child()` / `[属性名]` | 10          |
| ID `#id属性值{}`                                         | 100         |
| 内联样式 `style=""`                                      | 1000        |
| important  `.d1{ background-color: purple !important;}`  | 1/0(无穷大) |

# JS

## 内置类型

> **数据类型其实是值的类型，所以值就是具体数据**。**变量是命名的存储容器，是值的容器**。

### 概述

ECMAScript 规范规定语言类型有六种 `Undefined，Null，Boolean，String，Number，和 Object`， ES6 又添加了一种基本类型，叫`Symbol`。`BigInt`目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型。

其中 Object 是引用类型，其他是基本类型。他们的划分方式其实是其是否可以表示为固定长度， 比如`Undefined，Null，Boolean，String，Number` 这些可以有**固定长度**，因此是**基本类型**，并且保存到了**栈**上。 `Object` 由于**不可预知长度**，并且可以 mutate，因此算引用类型，会被分配到了另一块区域，我们称之为**堆（heap）**。

> 字符串是不可变的，因此被认为有固定长度。

[![IZyIN4.jpg](https://z3.ax1x.com/2021/11/04/IZyIN4.jpg)](https://imgtu.com/i/IZyIN4)

其实类型指的是**值的类型**，不是变量的类型，这是动态语言和静态语言的差异。 对于静态语言来说，我们可以限定一个变量的类型。但是对于 JS 这种动态类型的语言来说， 我们无法给变量限定类型，变量的类型是可变的。举个例子：

```js
var a = 1;
typeof a; // "number"

a = {};
typeof a; // "object"
```

### typeof

我们可以用`typeof` 来判断一个值是什么类型，他会返回上述的六种中的一种（事实上还会返回别的）， 返回值为**字符串**， 唯独不会返回 **null**。这是一个 bug,并且由于影响深远，已经无法去修复了。

```js
typeof null === "object"; // true
```

如果你想判断一个值是不是 null 类型，你可以这么判断:

```js
function isNull(any) {
  return !any && typeof any === "object";
}
```

typeof 还会返回一个特殊的类型，并不在上面的七种, 没错就是function

```js
typeof function a() {
  /* .. */
} === "function"; // true
```

最后我们来说下 undefined。其实这部分知识和**作用域和闭包**联系起来理解会更顺畅。

- undefined 不是未定义，两者有区别。尝试去读一个未定义的变量的值其实会直接`Reference Error`
- typeof 不能区分未定义，还是定义了但是没有值。**两者都会都会返回undefined**
- typeof 一个未定义的变量不会触发`Reference Error`

> 尽量不要用undefined, 因为undefined既是一个类型，同时也是一个值，因此这会在某些浏览器被修改（BUG？）。 更稳妥的做法是使用void 0 代替 undefined。

### Array

Array是一种容器类型，如果你懂的函数式编程或者了解范型的话，你会非常熟悉这个概念。

Array是一种容器类型，可以容纳任何类型，包括自己。如果Array里面容纳Array就会得到一个多维数组。 事实上，JS中有一些类数组， 类数组会有一些数据的属性和方法，但是确实被阉割的，因此对待类数组要小心， 一个稳妥的方法是转化为数组，比如使用`Array.from(arrayLike)` ,还有一种方法是借方法， 比如`Array.prototype.map.call(arrayLike)`。

> 其实你也可以用Array.prototype.slice.call(arrayLike) 来将类数组转化成数组。

String 其实就是字符的有序集合，因此我们可以将String看作Char的数组，准确地说，**String是一种类数组。**

### Number

JS 至今没有真正的整数，我们用的number事实上是浮点数。 JavaScript 明确地使用了“双精度”（也就是“64位二进制”）格式。

这部分常考的一个点是精度问题。

```js
0.1 + 0.2 === 0.3; // false
```

- 为什么会这样？

简单地说，0.1 和 0.2 的二进制表示形式是不精确的，所以它们相加时，结果不是精确地 0.3。而是**非常接近的值**：0.30000000000000004，但是如果你的比较失败了，“接近”是无关紧要的。

- 如何解决？

最常见的做法是使用一个很小的“错误舍入”值作为比较的 容差。 这个很小的值经常被称为“机械极小值（machine epsilon）”， 对于 JavaScript 来说这种 number 通常为 `Number.EPSILON`。

```js
function numbersCloseEnoughToEqual(n1,n2) {
    return Math.abs( n1 - n2 ) < Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual( a, b );                    // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );    // false
Copy to clipboardErrorCopied
```

### undefined与null的区别?

* undefined代表**定义未赋值**

* nulll**定义并赋值了, 只是值为null**

* 代码示例

  ```js
    var a
    console.log(a)  // undefined
    a = null
    console.log(a) // null
  ```

**什么时候给变量赋值为null呢?**

* 初始赋值, 表明将要赋值为对象,`可以用做约定俗成的占位符`

* 结束前, `让对象成为垃圾对象`(被垃圾回收器回收)

* 代码示例

  ```js
  //起始,可以用做约定俗成的占位符
    var b = null  // 初始赋值为null, 表明将要赋值为对象
    //确定对象就赋值
    b = ['atguigu', 12]
    //最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存      ---当没有引用指向它的对象称为垃圾对象
    b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) 
  ```

### `==`、`===`

可以判断: undefined, null

简而言之，在比较两件事情时，`双等号将执行类型转换`;` 三等号将进行相同的比较，而不进行类型转换` (如果类型不同, 只是总会返回 false 

### 其他

其他需要注意的是包装类型，以及对应的box和unbox操作。

举几个例子：

```js
typeof String(123) === 'string' // true
typeof '123' === 'string' // true
typeof new String(123)  === 'object' // true
```

## 作用域与闭包

### 作用域

作用域(即`scope`, 其实更确切地说是`lexical scope`)就是一套变量访问规则，这些规则包括**变量如何存储和访问，也就是规定了哪些变量可以被访问，哪些变量不可以被访问**。

假设有如下代码：

```js
function foo(a) {
  if (typeof a === "number" || a instanceof Number) {
    const b = a + 1;
    console.log(b);
  }
}
foo();
```

我们来看下这段代码。 这段代码在 JS 引擎执行的时候究竟发生了什么？ 这里我画了个图：

[![IZfuPU.jpg](https://z3.ax1x.com/2021/11/04/IZfuPU.jpg)](https://imgtu.com/i/IZfuPU)

如上图，左边部分是编译器。 右半部分是作用域链。上述代码执行的具体过程大概是：

- JS 源代码经过语法分析，转化成 `tokens`

- tokens 经过语义分析，转化为 `AST(抽象语法树)`

- 抽象语法树会被转化为字节码

- JS 运行时开始运行这段上面生成代码

- 当代码执行到函数声明的时候，引擎会向 `scope chain` 询问(一个 RHS)，`foo` 是否已经声明 在这里是没有声明，会在当前 scope(也就是 `global scope`)创建一个 foo

  > console 是 内置对象， 虽然不是我们声明的，但是它已经在全局作用域了。

- 执行 foo。 引擎同样会询问 scope chain(一个 RHS)，foo 是否已经声明。 在这里是声明了，如果没声明会报`Reference Error`。

- 代码进到了 foo， 我们创建一个新的作用域，这个作用域指向全局作用域，从而形成作用域链。

- 下次引擎发送 RHS，如果当前作用域找到就返回，找不到就沿着链找，最终都找不到就报`Reference Error`， 过程类似原型链。

> 注意图中块级作用域的位置，这也就解释了，为什么块级作用域声明的变量在块外面是无法访问的。

> 上述过程忽略了一些细节，比如生成 optimized AST 和 optimized byte code 的过程

事实上，作用域背后地原理是`词法环境`， 词法环境由两部分组成：

1. 环境记录， 这其实就是JavaScript用来存变量地地方，一个key-value对在这里被成为一个binding。
2. 外部环境的引用

其实它就是一个递归的数据结构，是不是有像刚才我们画的作用域？

我们需要特殊注意的是全局作用域，这是一个特殊的作用域，总是出现在作用域的最外层。全局作用域 对应的环境就是`全局环境`，全局作用域的`外部环境引用`是null。是不是感觉和原型链什么的都很像？

### 闭包

闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。

从理论上来说`JS 中一切函数都有闭包`，其原因就是 JS 和大多数编程语言一样采用的是静态作用域.

但是我们通常谈论的是`可观察的`闭包，什么是可观察？ 我们来举个例子，这是一个`可观察`的闭包例子：

```js
function foo(a) {
  const c = "closures";
  if (typeof a === "number" || a instanceof Number) {
    const b = a + 1;
    console.log(b);
  }
  return () => c;
}
const func = foo();
func(); // 'closures'
```

上面的代码foo作用域的c在foo的外侧被访问到了，这就是一个`可观察`的闭包.

为什么呢？ 这和上面的说的好像不太一样？ 不，是一样的。我同样画了一个图：

[![IZfM24.jpg](https://z3.ax1x.com/2021/11/04/IZfM24.jpg)](https://imgtu.com/i/IZfM24)

说的直白一点就是foo返回的函数`记住了ta被定义的时候的作用域`，因此你可以访问到foo里面定义的变量。 看起来好像是`突破了作用域的限制`，我们称之为`可观察`的闭包。

> 当然没有被这个返回的函数引用的变量还是会被GC销毁

## 引用和操作符优先级

```js
var a = { x: 1 };
var b = a;
a = a.x = { x: 1 };
console.log(a);
console.log(b);
```

答案：

- 先输出{x:1}
- 再输出{x:{x:1}}

解释：

解决这道题目的关键点有两个

1. .操作符的的运算优先级问题, `.`的优先级高于赋值语句
2. 能够明白浏览器的内存分配原理

为了方便理解，我画了内存图。

当执行到以下代码的时候

```js
var a = { x: 1 };
var b = a;
```

内存图如图所示：

[![IZhGlQ.jpg](https://z3.ax1x.com/2021/11/04/IZhGlQ.jpg)](https://imgtu.com/i/IZhGlQ)

然后，我们将下面代码拆解为:

```js
a.x = { x: 1 };
a = a.x;
```

当执行到

```js
a.x = { x: 1 };
```

的时候，内存是这样的：

[![IZhJyj.jpg](https://z3.ax1x.com/2021/11/04/IZhJyj.jpg)](https://imgtu.com/i/IZhJyj)

最后，当执行到：

```js
a = a.x;
```

的时候，内存图如下：

[![IZh8Sg.jpg](https://z3.ax1x.com/2021/11/04/IZh8Sg.jpg)](https://imgtu.com/i/IZh8Sg)

## 原型和继承

### 继承

继承是一种代码复用的方式。在面向对象编程中，继承是一个很重要的点。

在JS中继承背后的原理是原型`prototype`, 这种实现继承的方式，我们称之为原型继承。

### 全局对象

JS中一些全局内置函数，分别为Functon, Array, Object.

```js
console.log(Object); // -> ƒ Object() { [native code] }
console.log(Array); // -> ƒ Array() { [native code] }
console.log(Function); // -> ƒ Function() { [native code] }
```

- 所有的数组对象，都是由全局内置函数Array创建的
- 所有的object对象，都是由全局内置函数Object创建的
- 所有的函数对象，都是由全局内置函数Function创建的

其他也是同理，比如:

```js
1..__proto__ === Number.prototype; // true
1'.__proto__ === String.prototype; // true
true.__proto__ === Boolean.prototype; // true
```

### `__proto__`

`__proto__`是一个内部属性，不建议对其进行直接操作。 而是建议通过`prototype`来进行操作。

`一个对象的__proto__总是指向它的构造函数的prototype`。

> 构造函数指的是创建这个对象的函数， 比如 foo = new Foo(), 那么Foo就是foo的构造函数。

让我们来继续看一下上面的代码, 就不难理解了：

```js
1..__proto__ === Number.prototype; // true
1'.__proto__ === String.prototype; // true
true.__proto__ === Boolean.prototype; // true
```

除此我们需要注意一点，那就是`Object.prototype.__proto__` 值为 null。 其实也就是继承链的终点。

### 原型链

为了能够明白原型链和继承，我们首先要知道“属性查找机制”。

当我们访问一个对象的属性的时候，引擎首先会在当前对象进行查找，如果找不到就会访问该对象的`__proto__`， 如果`__proto__`有了，就返回，如果没有则递归执行上述过程，直到`__proto__` 为 `null`。

对于如下代码：

```js
var obj = {};

obj.access
```

引擎的内部逻辑大概是这样的：

```
__proto__ === null
|
|
__proto__ === Object.prototype
|
|
{ object literal }
```

如果用代码表示的话，大概是这样的：

```js
function  getProp(obj, prop) {
  let proto = obj;
  while(proto && proto[prop] === void 0) {
    proto = proto.__proto__;
  }
  return proto === null ? void 0 : obj[prop];
}
```

可以看出这个继承的过程，直接依靠的是`__proto__`， 只不过就像我上面提到的`__proto__ 只是一个指向构造函数原型的引用`， 因此开发人员修改了构造函数的原型，就会影响到`__proto__`， 进而影响了对象的原型链。

当然你可以自己直接修改`__proto__`，但是不推荐！

```js
var obj = {};
obj.__proto__.nickName = 'lucifer';
console.log(obj); // -> {}
console.log(obj.nickName); // -> lucifer
```

整个过程如图：

```
__proto__ === null
|
|
__proto__ === Object.prototype -> nickName: 'lucifer'
|
|
obj
```

### new

其实继承和原型这部分知识和new是强相关的。 我们有必要了解一下new的原理。

new 的原理很简单, 就是引擎内部新建一个空对象，然后将这个空对象的`__proto__` 指向构造函数的`prototype`.然后调用构造函数，去填充我们创建的空对象(如果有必要)。 最后将`this`指向我们刚刚创建的新对象。

如果用代码来表示，大概是这样的：

```js
function myNew(constructor, ...args) {
  const obj = {};
  obj.__proto__ = constructor.prototype;
  const ret = constructor.call(obj, ...args);
  return ret instanceof Object ? ret : obj;
}
```

#### 检测一下

我们来看一段代码，来检测一下我们的学习成果。

```js
function Fn() {}
var obj = new Fn();
console.log(obj.__proto__ === Fn.prototype);
// -> true
console.log(obj.__proto__.__proto__=== Object.prototype);
// -> true
console.log(obj.__proto__.__proto__.__proto__ === null);
// -> true
```

用图来表示大概是这样的：

```js
__proto__ === null
|
|             
__proto__ === Object.prototype
|
|
__proto__ === Fn.prototype
|
|
obj
```

### 总结

这一节我们讲解了原型prototype，属性查找机制，以及原型链。

我们直到了实现继承实际上是基于`__proto__`的，而不是prototype. 我们可以通过构造函数的原型从而修改对象的`__proto__`。

经过上面的讲解，如果你想实现继承也就不是难事了。

最后来两个思考题：

- 如果我不使用继承来实现代码复用，而是直接挂载到当前对象（this）上，会有什么问题。
- 如果我们把对象的私有属性挂载到原型上会发生了什么？



## DOM事件总结

> **知识点主要包括以下几个方面：**
>
> - 基本概念：DOM事件的级别
>
>   面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 ....”。
>
> - DOM事件模型、DOM事件流
>
>   面试官如果问你“**DOM事件模型**”，你不一定知道怎么回事。其实说的就是**捕获和冒泡**。
>
>   **DOM事件流**，指的是事件传递的**三个阶段**。
>
> - 描述DOM事件捕获的具体流程
>
>   讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。
>
> - Event对象的常见应用（Event的常用api方法）
>
>   DOM事件的知识点，一方面包括事件的流程；
>
>   另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。
>
> - 自定义事件（非常重要）
>
>   一般人可以讲出事件和注册事件，但是如果让你讲**自定义事件**，能知道的人，就更少了。
>
> - 事件委托
>
>   业务中经常用到。

### DOM事件的级别

DOM事件的级别，准确来说，是**DOM标准**定义的级别。包括：

**DOM0的写法：**


```javascript
//这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的
element.onclick = function () {
    alert('hello');
}
```

上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。

```html
<button onclick="alert('hello');">我是按钮</button>  
```

**DOM2的写法：**


```javascript
// 高版本浏览器
element.addEventListener('click', function () {
	alert('hello');
}, false);
```

【重要】上面的第三参数中，**true**表示事件在**捕获阶段**触发，**false**表示事件在**冒泡阶段**触发（默认）。如果不写，则默认为false。

```js
// IE8及以下版本浏览器
element.attachEvent('onclick', function () {
	alert('hello');
});
```

- 参数1：事件名的字符串(注意，有**on**)
- 参数2：回调函数：当事件触发时，该函数会被执行

不同：

* `addEventListener()`中的`this`，是**绑定事件的对象**。绑定多个响应函数执行顺序是：**先绑定先执行**。

* `attachEvent()`中的`this`是**window** 。绑定多个响应函数执行顺序是，**后绑定先执行**。

兼容写法：

```js
//定义一个函数，用来为指定元素绑定响应函数
/*
 * addEventListener()中的this，是绑定事件的对象
 * attachEvent()中的this，是window
 *  需要统一两个方法this
 */
/*
 * 参数：
 *  element 要绑定事件的对象
 *  eventStr 事件的字符串(不要on)
 *  callback 回调函数
 */
function myBind(element , eventStr , callback){
    if(element.addEventListener){
        //大部分浏览器兼容的方式
        element.addEventListener(eventStr , callback , false);
    }else{
        /*
         * this是谁，由调用方式决定
         * callback.call(element)
         */
        //IE8及以下
        element.attachEvent("on"+eventStr , function(){
            //在匿名函数 function 中调用回调函数callback
            callback.call(element);
        });
    }
}
```

补充：**call()、apply()、bind() 都是用来重定义 this 这个对象的！**bind 返回的是一个新的函数，你必须调用它才会被执行。

**DOM3的写法：**


```javascript
element.addEventListener('keyup', function () {
	alert('hello');
}, false);
```

DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。


PS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。

**总结**：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。

### DOM事件模型、DOM事件流

#### DOM事件模型

DOM事件模型讲的就是**捕获和冒泡**，一般人都能回答出来。

- 捕获：从上往下。

- 冒泡：从下（目标元素）往上。

#### DOM事件流

DOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。

类似于Android里面的事件传递。

完整的事件流，分三个阶段：

- （1）捕获：从 window 对象传到 目标元素。

- （2）目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。

- （3）冒泡：从**目标元素**传到 Window 对象。

[![5KPszR.png](https://z3.ax1x.com/2021/10/13/5KPszR.png)](https://imgtu.com/i/5KPszR)

[![5KP6Q1.jpg](https://z3.ax1x.com/2021/10/13/5KP6Q1.jpg)](https://imgtu.com/i/5KP6Q1)


#### 描述DOM事件捕获的具体流程

##### 捕获的流程

[![5KPrW9.png](https://z3.ax1x.com/2021/10/13/5KPrW9.png)](https://imgtu.com/i/5KPrW9)


**说明**：捕获阶段，事件依次传递的顺序是：window --> document --> html--> body --> 父元素、子元素、目标元素。

PS1：第一个接收到事件的对象是 **window**（有人会说body，有人会说html，这都是错误的）。

PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。

代码如下：


```javascript
window.addEventListener("click", function () {
    alert("捕获 window");
}, true);

document.addEventListener("click", function () {
    alert("捕获 document");
}, true);

document.documentElement.addEventListener("click", function () {
    alert("捕获 html");
}, true);

document.body.addEventListener("click", function () {
    alert("捕获 body");
}, true);

fatherBox.addEventListener("click", function () {
    alert("捕获 father");
}, true);

childBox.addEventListener("click", function () {
    alert("捕获 child");
}, true);

```


**补充一个知识点：**

在 js中：

- 如果想获取 `body` 节点，方法是：`document.body`；

- 但是，如果想获取 `html`节点，方法是`document.documentElement`。


##### 冒泡的流程

与捕获的流程相反

### Event对象的常见 api 方法

用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：

#### 方法一

```javascript
event.preventDefault();
```

解释：阻止默认事件。

比如，已知`<a>`标签绑定了click事件，此时，如果给`<a>`设置了这个方法，就阻止了链接的默认跳转。

#### 方法二：阻止冒泡

这个在业务中很常见。

有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。


w3c的方法：（火狐、谷歌、IE11）

```javascript
event.stopPropagation();
```

IE10以下则是：

```javascript
event.cancelBubble = true;
```

兼容代码如下：

```javascript
box3.onclick = function (event) {

    alert("child");

    
    //在IE8及以下的浏览器中，是将事件对象作为**window对象的属性**保存的
    event = event || window.event;
    //阻止冒泡
    if (event && event.stopPropagation) {
        event.stopPropagation();
    } else {
        event.cancelBubble = true;
    }
}
```

上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。


#### 方法三：设置事件优先级


```javascript
event.stopImmediatePropagation();
```

这个方法比较长，一般人没听说过。解释如下：

比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到`stopImmediatePropagation`方法了。做法是：在事件A的响应函数中加入这句话。

大家要记住 event 有这个方法。

#### 属性4、属性5（事件委托中用到）


```javascript
event.currentTarget   //返回绑定事件的元素。在事件委托中，指的是【父元素】。
event.target  //返回触发事件的元素。在事件委托中，指的是【子元素】。
```

上面这两个属性，在事件委托中经常用到。

**总结**：上面这几项，非常重要，但是容易弄混淆。


### 自定义事件

自定义事件的代码如下：


```javascript
var myEvent = new Event('clickTest');
element.addEventListener('clickTest', function () {
    console.log('smyhvae');
});

//元素注册事件
element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
```

上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：

```javascript
var myEvent = new Event('clickTest');

element.addEventListener('clickTest', function () {
    console.log('smyhvae');
});

setTimeout(function () {
    element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest
}, 1000);
```


### 事件委托

事件委派指将事件统一绑定给元素的**共同的祖先元素**，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。  事件委派是利用了**冒泡**，通过委派可以减少事件绑定的次数，提高程序的性能。		

## this指向

> 引言

要理解`this`的设计，我们需要先了解`Javascript`中内存的数据结构；

`Javascript`内置七种数据类型，可以分为**基本数据类型**和**对象数据类型**，在这里我们主要讲解一下**对象数据类型**在内存中的存储方式；

```js
var obj = { name: 'Heternally'};Copy to clipboardErrorCopied
```

`Javascript`引擎在处理上面代码时，会在**堆内存**中，生成一个对象`{ name: 'Heternally'}`，然后把这个对象在内存中的地址赋值给变量`obj`。所以在读取`obj.name`时，需要先从变量`obj`拿到地址，然后再从对应地址中拿到对象，再返回它的`name`属性。

可能看到这里会有同学要问这跟`this`有啥关系，别急，接下来重点来啦：

对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在**堆**中，然后再将函数的地址赋值给对象属性；而`Javascript`是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了`this`，**它的设计目的就是指向函数运行时所在的环境。**

> 如何正确判定this指向

总结了`this`的绑定规则总共是有下面5种：请记住一点：==谁调用这个函数或方法,this关键字就指向谁。==

- 1、默认绑定（严格/非严格模式）
- 2、隐式绑定
- 3、显式绑定
- 4、new绑定
- 5、ES6箭头函数绑定

### 默认绑定

#### 严格模式

在严格模式下，不能将全局对象`window`作为默认绑定，此时`this`会绑定到`undefined`，但是在严格模式下调用函数则不会影响默认绑定。

```js
(() => {
  "use strict"
  function foo() {
    console.log(this.name);
  };
  var name = "Heternally";
  foo(); 
})();

// Uncaught TypeError: Cannot read property 'name' of undefined at fooCopy to clipboardErrorCopied
var name = 'Heternally';
function foo() {
  console.log(this.name);
};

(() => {
  "use strict"
  foo();
})();

// Heternally
```

#### 非严格模式

在非严格模式下，此时`this`就指向**全局对象**

```js
var name = 'Heternally';
function foo() {
  console.log(this.name);
}

foo(); // HeternallyCopy to clipboardErrorCopied
```

### 隐式绑定

当函数作为对象的属性存在，通过**对象属性执行函数**时，此时隐式绑定规则会将`this`绑定到对象上；

```js
var name = 'Heternally';
function foo() {
  console.log(this.name);
}

var obj = {
  name: 'zl',
  foo,
}

obj.foo(); // zl
```

注意上面代码中函数执行方式是通过**对象属性**执行

```js
var name = 'Heternally';
function foo() {
  console.log(this.name);
}

var obj = {
  name: 'zl',
  foo,
}

foo(); // Heternally

var foo1 = obj.foo; 

foo1(); // Heternally

obj.foo(); // zl
```

由上面代码可以发现，通过赋值操作后执行函数，会应用默认绑定，此时在非严格模式下`this`会指向全局对象。

同样的，函数传参也是一种隐式赋值，此时在回调函数中会丢失`this`绑定。

```js
function foo() {
  console.log(this.name);
}

function Foo(fn) {
  fn();
}

var obj = {
  name: 'zl',
  foo,
}

var name = 'Heternally';

Foo(obj.foo); // Heternally
```

### 显式绑定

**通过 `call` `apply` `bind`绑定**

相信同学们都知道这三个方法的作用，这边就主要拿`call`来举例；

> 一句话介绍`call`：使用一个指定的`this`和若干个指定的参数调用某个函数或方法。

在讲解`call`显示绑定之前，我们先想一下`call`做了哪些事儿。

- 将函数设为对象的属性
- 指定函数的this，并进行传参
- 执行&删除函数
- 判定如果没有指定要绑定的this，非严格模式下默认指向全局对象

可以看到值调用`call`方法后，会将`this`绑定到指定对象，所以称为**显示绑定**

```js
function foo() {
  console.log(this.name);
}

var obj = {
  name: 'Heternally',
}

var obj1 = {
  name: 'Heternally1'
}

var name = 'zl';

foo.call(obj); // Heternally  调用call方法后强行将foo函数的this指向来obj对象上

foo.call(obj).call(obj1); // Heternally  多次调用call方法，以第一次为准

foo.call(obj1).call(obj); // Heternally1

foo.call();// zl 没有传入指定对象，所以this默认指向全局对象
```

> 如果call、apple、bind的绑定对象是null或者undefined，那么实际上在调用时这些值都会被忽略，所以使用的是默认绑定规则

### 通过new绑定

我们先看看构造函数在使用`new`后，执行了什么操作：

- 它创建（构造）了一个全新的对象
- 它会被执行[[Prototype]]（也就是__proto__）链接
- 它使this指向新创建的对象
- 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
- 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用

所以在使用`new`调用构造函数后，会构造一个新对象并将函数调用中的`this`绑定到新对象上。

```js
var name = 'zl';

function foo(name) {
  this.name = name;
}

var bar = {
  name: 'object',
  foo1: new foo('Heternally'),
}

console.log(bar.foo1.name); // Heternally
```

构造函数是存在返回值的，可以将函数的返回值分成三种情况：

- 返回一个对象
- 没有返回值，即默认返回`undefined`
- 返回基本数据类型

```js
1、返回一个对象
function Foo(name,age) {
  this.name = name;
  return {
    age
  }
}

var bar = new Foo("Heternally","18");

bar.name; // undefined

bar.age; // 18

2、没有返回值

function Foo(name,age) {
  this.name = name;
}

var bar = new Foo("Heternally","18");

bar.name; // Heternally

bar.age; // undefined

3、返回基本数据类型

function Foo(name,age) {
  this.name = name;
  return 123
}

var bar = new Foo("Heternally","18");

bar.name; // Heternally

bar.age; // undefined
```

所以使用`new`绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么`this`会绑定到返回的对象上。

### ES6箭头函数绑定

ES6新增了一种函数类型：箭头函数，箭头函数调用时无法使用上面四种规则了，它和普通函数最不同的一点就是对于箭头函数的`this`指向，是根据它外层（函数/全局）作用域来决定。

```js
function foo() {
  return (name) => {
    console.log(this.name);
  }
}

var obj = {
  name: 'Heternally'
}

var obj1 = {
  name: 'text'
}

var name = 'zl';

var foo1 = foo();
foo1(); // zl

var foo2 = foo.call(obj);
foo2(); // Heternally

foo2.call(obj1); // Heternally 可以看到，箭头函数的`this`绑定后无法被修改
```

### 规则优先级

```js
1、new绑定
var obj = new Foo();
this绑定新的对象上

2、显示绑定
var obj = foo.call(bar);
this绑定到指定对象上，若指定对象为null/undefined或着没传，则使用默认绑定规则

3、隐式绑定
var obj = bar.foo();
this绑定到调用方法的对象上

4、默认绑定
foo();
this在严格模式下绑定到undefined
在非严格模式下绑定到全局对象Copy to clipboardErrorCopied
```

# 计算机网络和浏览器

## HTTP协议

> 一面要讲的内容：
>
> - HTTP协议的主要特点
>
> - HTTP报文的组成部分
>
> - HTTP方法
>
> - get 和 post的区别
>
> - HTTP状态码
>
> - 什么是持久连接
>
> - 什么是管线化
>
>
> 二面要讲的内容；
>
> - 缓存
> - CSRF攻击

### HTTP协议的主要特点

- 简单快速

- 灵活

- **无连接**

- **无状态**


通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：**无连接、无状态**。


我们分别来解释一下。

**简单快速**

每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。

**灵活**

http协议的头部有一个`数据类型`，通过http协议，就可以完成不同数据类型的传输。

**无连接**

连接一次，就会断开，不会继续保持连接。

**无状态**

客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，**服务器端并没有记住之前的状态**，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。

有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。

### HTTP报文的组成部分

[![5KMFne.png](https://z3.ax1x.com/2021/10/13/5KMFne.png)](https://imgtu.com/i/5KMFne)

在回答此问题时，我们要按照顺序回答：

- 先回答的是，http报文包括：**请求报文**和**响应报文**。

- 再回答的是，每个报文包含什么部分。

- 最后回答，每个部分的内容是什么

#### 请求报文包括：

[![5KMk0H.jpg](https://z3.ax1x.com/2021/10/13/5KMk0H.jpg)](https://imgtu.com/i/5KMk0H)

- 请求行：包括请求方法、请求的url、http协议及版本。

- 请求头：一大堆的键值对。

- **空行**指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。

- 请求体：数据部分。

#### 响应报文包括：

[![5KMPXD.jpg](https://z3.ax1x.com/2021/10/13/5KMPXD.jpg)](https://imgtu.com/i/5KMPXD)


- 状态行：http协议及版本、状态码及状态描述。
- 响应头
- 空行
- 响应体

### HTTP方法

包括：

- GET：获取资源

- POST：传输资源

- put：更新资源

- DELETE：删除资源

- HEAD：获得报文首部

HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。

get 和 post 比较常见。

put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。

head 可能偶尔用的到。


#### get 和 post的区别

[![5KQEKU.png](https://z3.ax1x.com/2021/10/13/5KQEKU.png)](https://imgtu.com/i/5KQEKU)

区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。

有一点要强调，**get是相对不隐私的，而post是相对隐私的**。

我们大概要记住以下几点：

* 浏览器在回退时，get**不会重新请求**，但是post会重新请求。【重要】
* get请求会被浏览器**主动缓存**，而post不会。【重要】
* get请求的参数，会报**保留**在浏览器的**历史记录**里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。
* get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有注意。
* get的参数是直接暴露在**url**上的，相对不安全。而post是放在**请求体**中的。

### http状态码

http状态码分类：

[![5KlEWt.png](https://z3.ax1x.com/2021/10/13/5KlEWt.png)](https://imgtu.com/i/5KlEWt)

常见的http状态码：

[![5KleQf.png](https://z3.ax1x.com/2021/10/13/5KleQf.png)](https://imgtu.com/i/5KleQf)

- 206的应用：`range`指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。


- 301：重定向（永久）。

- 302：重定向（临时）。

- 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。

[![5KlZSP.png](https://z3.ax1x.com/2021/10/13/5KlZSP.png)](https://imgtu.com/i/5KlZSP)

400和401用的不多。403指的是请求被拒绝。404指的是资源不存在。

### 持久链接/http长连接


- **轮询**：**http1.0**中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。


- **长连接**：**HTTP1.1**中，通过使用`Connection:keep-alive`进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。

注意，**HTTP 1.1**默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对**每个请求仍然要单独发 header**，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

#### 长连接中的管线化

长连接时，**默认**的请求这样的：

```bash
请求1 --> 响应1 -->请求2 --> 响应2 --> 请求3 --> 响应3
```

长连接中的管线化，请求是这样的：

```bash
请求1 --> 请求2 --> 请求3 --> 响应1 --> 响应2 --> 响应3
```


管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。

## 跨域通信

> 前端通信类的问题，主要包括以下内容：
>
> - 什么是**同源策略**及限制
>
>   同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。
>
> - **前后端如何通信**
>
>   如果你不准备，估计也就只能说出ajax。这个可以考察出知识面。
>
> - 如何创建**Ajax**
>
>   Ajax在前后端通信中经常用到。做业务时，可以借助第三方的库，比如vue框架里的库、jQuery也有封装好的方法。但如果让你用原生的js去实现，该怎么做？
>
>   这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。
>
> - **跨域通信**的几种方式
>
>   这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、**跨域有几种方式**。

### 同源策略的概念和具体限制

**同源策略**：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。

具体解释：

（1）`源`包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则`源`不同，那就是跨域了。

（2）`限制`：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：

- **Cookie**、**LocalStorage**和**IndexDB**无法获取。
- 无法获取和操作**DOM**。
- 不能发送**Ajax**请求。我们要注意，Ajax只适合**同源**的通信。

### 前端的存储方式

|     特性     |                   cookie                   |       localStorage       | sessionStorage |         indexDB          |
| :----------: | :----------------------------------------: | :----------------------: | :------------: | :----------------------: |
| 数据生命周期 |     一般由服务器生成，可以设置过期时间     | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 |                     4K                     |            5M            |       5M       |           无限           |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 |          不参与          |     不参与     |          不参与          |

从上表可以看到，`cookie` 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 `localStorage` 和 `sessionStorage` 。对于不怎么改变的数据尽量使用 `localStorage` 存储，否则可以用 `sessionStorage` 存储。

对于 `cookie`，我们还需要注意安全性。

|   属性    |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   value   | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |
| http-only |            不能通过 JS 访问 Cookie，减少 XSS 攻击            |
|  secure   |               只能在协议为 HTTPS 的请求中携带                |
| same-site |    规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击     |

### 前后端如何通信

主要有以下几种方式：

- **Ajax**：不支持跨域。

- **WebSocket**：不受同源策略的限制，支持跨域。

- **CORS**：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：**同时支持同源和跨域的Ajax**。

### 如何创建Ajax

在回答 Ajax 的问题时，要回答以下几个方面：

- 1、XMLHttpRequest 的工作原理

- 2、兼容性处理

  XMLHttpRequest只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。

- 3、事件的触发条件

- 4、事件的触发顺序

  XMLHttpRequest有很多触发事件，每个事件是怎么触发的。

#### 发送 Ajax 请求的五个步骤

> XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。

* 创建`XMLHttpRequest` 对象。

* 使用`open`方法设置请求的参数。`open(method, url, 是否异步)`。

* 发送请求。

* 注册事件。 注册`onreadystatechange`事件，状态改变时就会调用。

  如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。

* 获取返回的数据，更新UI。

#### 发送 get 请求和 post 请求

get请求举例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<h1>Ajax 发送 get 请求</h1>
<input type="button" value="发送get_ajax请求" id='btnAjax'>

<script type="text/javascript">
    // 绑定点击事件
    document.querySelector('#btnAjax').onclick = function () {
        // 发送ajax 请求 需要 五步

        // （1）创建异步对象
        var xhr = new XMLHttpRequest();

        // （2）设置请求的参数。包括：请求的方法、请求的url。
        xhr.open('get', '02-ajax.php');

        // （3）发送请求
        xhr.send();

        //（4）注册事件。 onreadystatechange事件，状态改变时就会调用。
        //如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。
        xhr.onreadystatechange = function () {
            // 为了保证 数据 完整返回，我们一般会判断 两个值
            if (xhr.readyState == 4 && xhr.status == 200) {
                // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
                // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示
                console.log('数据返回成功');

                // 数据是保存在 异步对象的 属性中
                console.log(xhr.responseText);

                // 修改页面的显示
                document.querySelector('h1').innerHTML = xhr.responseText;
            }
        }
    }
</script>
</body>
</html>
```

post 请求举例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<h1>Ajax 发送 get 请求</h1>
<input type="button" value="发送put_ajax请求" id='btnAjax'>
<script type="text/javascript">

    // 异步对象
    var xhr = new XMLHttpRequest();

    // 设置属性
    xhr.open('post', '02.post.php');

    // 如果想要使用post提交数据,必须添加此行
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

    // 将数据通过send方法传递
    xhr.send('name=fox&age=18');

    // 发送并接受返回值
    xhr.onreadystatechange = function () {
        // 这步为判断服务器是否正确响应
        if (xhr.readyState == 4 && xhr.status == 200) {
            alert(xhr.responseText);
        }
    };
</script>
</body>
</html>
```

#### onreadystatechange 事件

注册 `onreadystatechange` 事件后，每当 `readyState` 属性改变时，就会调用 `onreadystatechange` 函数。

`readyState`：（存有 `XMLHttpRequest` 的状态。从 0 到 4 发生变化）

- 0: 请求未初始化

- 1: 服务器连接已建立

- 2: 请求已接收

- 3: 请求处理中

- 4: 请求已完成，且响应已就绪

#### 事件的触发条件

[![5KtjKI.png](https://z3.ax1x.com/2021/10/13/5KtjKI.png)](https://imgtu.com/i/5KtjKI)

#### 事件的触发顺序

[![5KtOxA.png](https://z3.ax1x.com/2021/10/13/5KtOxA.png)](https://imgtu.com/i/5KtOxA)

### 跨域通信的几种方式

方式如下：

- 1、JSONP

- 2、WebSocket

- 3、CORS

- 4、Hash

- 5、postMessage

上面这五种方式，在面试时，都要说出来。

#### JSONP

面试会问：JSONP的原理是什么？怎么实现的？

在CORS和postMessage以前，我们一直都是通过JSONP来做跨域通信的。

**JSONP的原理**：通过`<script>`标签的异步加载来实现的。比如说，实际开发中，我们发现，head标签里，可以通过`<script>`标签的src，里面放url，加载很多在线的插件。这就是用到了JSONP。

**JSONP的实现：**

比如说，客户端这样写：

```html
<script src="http://www.smyhvae.com/?data=name&callback=myjsonp"></script>
```

上面的src中，`data=name`是get请求的参数，`myjsonp`是和后台约定好的函数名。
服务器端这样写：

```bash
myjsonp({
	data: {}
})
```


于是，本地要求创建一个myjsonp 的**全局函数**，才能将返回的数据执行出来。

**实际开发中，前端的JSONP是这样实现的：**

```html
<script>

    var util = {};

    //定义方法：动态创建 script 标签
    /**
     * [function 在页面中注入js脚本]
     * @param  {[type]} url     [description]
     * @param  {[type]} charset [description]
     * @return {[type]}         [description]
     */
    util.createScript = function (url, charset) {
        var script = document.createElement('script');
        script.setAttribute('type', 'text/javascript');
        charset && script.setAttribute('charset', charset);
        script.setAttribute('src', url);
        script.async = true;
        return script;
    };


    /**
     * [function 处理jsonp]
     * @param  {[type]} url      [description]
     * @param  {[type]} onsucess [description]
     * @param  {[type]} onerror  [description]
     * @param  {[type]} charset  [description]
     * @return {[type]}          [description]
     */
    util.jsonp = function (url, onsuccess, onerror, charset) {
        var callbackName = util.getName('tt_player'); //事先约定好的 函数名
        window[callbackName] = function () {      //根据回调名称注册一个全局的函数
            if (onsuccess && util.isFunction(onsuccess)) {
                onsuccess(arguments[0]);
            }
        };
        var script = util.createScript(url + '&callback=' + callbackName, charset);   //动态创建一个script标签
        script.onload = script.onreadystatechange = function () {   //监听加载成功的事件，获取数据
            if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                script.onload = script.onreadystatechange = null;
                // 移除该script的 DOM 对象
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
                // 删除函数或变量
                window[callbackName] = null;  //最后不要忘了删除
            }
        };
        script.onerror = function () {
            if (onerror && util.isFunction(onerror)) {
                onerror();
            }
        };
        document.getElementsByTagName('head')[0].appendChild(script); //往html中增加这个标签，目的是把请求发送出去
    };

</script>

```

#### WebSocket

WebSocket的用法如下：

```javascript
var ws = new WebSocket('wss://echo.websocket.org'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。

//把请求发出去
ws.onopen = function (evt) {
    console.log('Connection open ...');
    ws.send('Hello WebSockets!');
};


//对方发消息过来时，我接收
ws.onmessage = function (evt) {
    console.log('Received Message: ', evt.data);
    ws.close();
};

//关闭连接
ws.onclose = function (evt) {
    console.log('Connection closed.');
};
```

面试一般不会让你写这个代码，一般是考察你是否了解 WebSocket概念，知道有这么回事即可。

#### CORS

> **CORS是什么?**
>
> CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get和post请求。跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源
>
> **CORS是怎么工作的?**
>
> CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。

CORS 可以理解成是**既可以同步、也可以异步**的Ajax。

fetch 是一个比较新的API，用来实现CORS通信。用法如下：

```javascript
// url（必选），options（可选）
fetch('/some/url/', {
    method: 'get',
}).then(function (response) {  //类似于 ES6中的promise

}).catch(function (err) {
    // 出错了，等价于 then 的第二个参数，但这样更好用更直观
});
```

另外，如果面试官问：“CORS为什么支持跨域的通信？”

答案：跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。

#### Hash

url的`#`后面的内容就叫Hash。**Hash的改变，页面不会刷新**。这就是用 Hash 做跨域通信的基本原理。

补充：url的`?`后面的内容叫Search。Search的改变，会导致页面刷新，因此不能做跨域通信。

**使用举例：**

**场景**：我的页面 A 通过iframe或frame嵌入了跨域的页面 B。

现在，我这个A页面想给B页面发消息，怎么操作呢？

（1）首先，在我的A页面中：

```javascript
//伪代码
var B = document.getElementsByTagName('iframe');
B.src = B.src + '#' + 'jsonString';  //我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B
```

（2）然后，在B页面中：

```javascript
// B中的伪代码
window.onhashchange = function () {  //通过onhashchange方法监听，url中的 hash 是否发生变化
    var data = window.location.hash;
};
```

#### postMessage()方法

> H5中新增的postMessage()方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。

**场景**：窗口 A (`http:A.com`)向跨域的窗口 B (`http:B.com`)发送信息。步骤如下。

（1）在A窗口中操作如下：向B窗口发送数据：


```javascript
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
Bwindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象
```

（2）在B窗口中操作如下：

```javascript
// 在窗口B中监听 message 事件
Awindow.addEventListener('message', function (event) {   //这里强调的是A窗口里的window对象
    console.log(event.origin);  //获取 ：url。这里指：http://A.com
    console.log(event.source);  //获取：A window对象
    console.log(event.data);    //获取传过来的数据
}, false);
```

## 从URL输入到页面展现到底发生什么？

[![5JDg5F.png](https://z3.ax1x.com/2021/10/16/5JDg5F.png)](https://imgtu.com/i/5JDg5F)

总体来说分为以下几个过程:

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

### URL 到底是啥

URL（Uniform Resource Locator），统一资源定位符，用于定位互联网上资源，俗称网址。

遵守以下的语法规则：`scheme://host.domain:port/path/filename`

* **scheme** - 定义因特网服务的类型。常见的协议有 **http、https、ftp、file**，其中最常见的类型是 http，而 **https 则是进行加密的网络传输**。
* **host** - 定义域主机（http 的默认主机是 **www**）
* **domain** - 定义因特网**域名**，比如 `w3school.com.cn`
* **port** - 定义主机上的**端口号**（http 的默认端口号是 80）
* **path** - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。
* **filename** - 定义文档/资源的名称

### 域名解析（DNS）

在浏览器输入网址后，首先要经过**域名解析**，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 **IP 地址**。

#### IP 地址

IP 地址是指互联网协议地址，是 IP Address 的缩写。

IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。

**域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址**。

用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。

**因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。**

**但要让计算机去理解名称，相对而言就变得困难了。**

**因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。**

#### 什么是域名解析

DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。

**DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录**。

```armasm
例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）
```

#### 浏览器如何通过域名去查询 URL 对应的 IP 呢

- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。
- 路由缓存：路由器也有 DNS 缓存。
- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

[![5JruZV.png](https://z3.ax1x.com/2021/10/16/5JruZV.png)](https://imgtu.com/i/5JruZV)

#### 小结

**浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，**

**浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。**

**接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。**

[![5JrWo8.png](https://z3.ax1x.com/2021/10/16/5JrWo8.png)](https://imgtu.com/i/5JrWo8)

### TCP 三次握手

**在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息**。
[![5JrIzj.png](https://z3.ax1x.com/2021/10/16/5JrIzj.png)](https://imgtu.com/i/5JrIzj)

#### TCP 三次握手的过程如下：

- **客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口**（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
- **服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息**（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
- **客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”**（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

#### 为啥需要三次握手

谢希仁著《计算机网络》中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

### 发送 HTTP 请求

### 服务器处理请求并返回 HTTP 报文

#### 服务器

服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机（客户机）提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。 每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。
**web server 担任管控的角色**，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。

[![5J6Yss.png](https://z3.ax1x.com/2021/10/16/5J6Yss.png)](https://imgtu.com/i/5J6Yss)

#### MVC 后台处理阶段

后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。MVC 是一个设计模式，将应用程序分成三个核心部件：模型（model）-- 视图（view）--控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。
[![5J68zQ.png](https://z3.ax1x.com/2021/10/16/5J68zQ.png)](https://imgtu.com/i/5J68zQ)

> 1、视图（view）

**它是提供给用户的操作界面，是程序的外壳。**

> 2、模型（model）

**模型主要负责数据交互。**在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。

> 3、控制器（controller）

**它负责根据用户从"视图层"输入的指令，选取"模型层"中的数据，然后对其进行相应的操作，产生最终结果。**控制器属于管理者角色，从视图接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。
这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。
至于这一阶段发生什么？简而言之，**首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。**

#### http 响应报文

### 浏览器解析渲染页面

浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制

[![5J63Rg.png](https://z3.ax1x.com/2021/10/16/5J63Rg.png)](https://imgtu.com/i/5J63Rg)

浏览器解析渲染页面分为一下五个步骤：

- 根据 HTML 解析出 DOM 树
- 根据 CSS 解析生成 CSS 规则树
- 结合 DOM 树和 CSS 规则树，生成渲染树
- 根据渲染树计算每一个节点的信息
- 根据计算好的信息绘制页面

### 七、断开连接

**当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手**。
[![5J6JMj.png](https://z3.ax1x.com/2021/10/16/5J6JMj.png)](https://imgtu.com/i/5J6JMj)

- **发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态**。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
- **被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态**。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
- **被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态**。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
- **发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭**。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)



